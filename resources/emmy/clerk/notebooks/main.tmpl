;; # Welcome to [Clerk](https://clerk.vision/)!

^{:nextjournal.clerk/toc true}
(ns {{top/ns}}.{{main/ns}}
    (:refer-clojure
     :exclude [+ - * / zero? compare divide numerator denominator
               infinite? abs ref partial =])
    (:require [emmy.env :as e :refer :all]
              [nextjournal.clerk :as clerk]))

;; Hello! This project was generated by the [`emmy/clerk`
;; template](https://emmy.mentat.org/#project-template). The template comes with
;; everything you need you everything you need to

;; - Interactively develop Clerk notebooks
;; - Publish them to [GitHub Pages](https://pages.github.com/) or [Clerk's Garden](https://github.clerk.garden/)
;; - Use a [custom ClojureScript build](https://clerk-utils.mentat.org/#custom-clojurescript-builds) in both modes

;; Some good next steps:

;; - Visit this project's README.md for guides on how to proceed.
;; - Read the [`Emmy` documentation notebook](https://emmy.mentat.org)
;; - Read the [Book of Clerk](https://book.clerk.vision/)
;; - Visit the [Awesome-Clerk](https://github.com/mentat-collective/awesome-clerk) list for ideas
;; - Delete anything in this notebook you feel like you don't need.

;; ## Clerk Environment Basics
;;
;; Here's a basic use of Clerk. This is a function:

(defn hello [s]
  (str "Hello, " s "!"))

;; If we call this function, Clerk will render the form and its output:

(hello "Clerk")

;; - The form `(hello "Clerk")` executes in the JVM.
;; - The resulting string "Hello, Clerk!" is serialized over a WebSocket to the
;;   browser, where Clerk's ClojureScript side renders it using a
;;   pre-registered "viewer".
;; - These viewers are written in code evaluated using the [Small Clojure
;;   Interpreter](https://github.com/babashka/sci), or "SCI".

;; Clerk comes with [many viewers](https://book.clerk.vision/#viewers), and
;; gives us the ability to [write _new_
;; viewers](https://book.clerk.vision/#writing-viewers) using a default SCI
;; environment that Clerk makes available to us.

;; ## Emmy Quickstart

;; The following snippet implements the example from
;; the ["Quickstart"](https://emmy.mentat.org/#quickstart) section of
;; the [`Emmy` docs notebook](https://emmy.mentat.org/#quickstart).

;; ### Arithmetic / Numeric Tower

;; Math works as
;; expected (se [Generics](https://cljdoc.org/d/org.mentat/emmy/CURRENT/doc/basics/generics)
;; for the full menu of operations), but notice that the numeric tower
;; includes [complex
;; numbers](https://cljdoc.org/d/org.mentat/emmy/CURRENT/doc/data-types/complex),
;; and proper ratios in ClojureScript:

(- (* 7 (/ 1 2)) 2)

(->infix (asin -10))

;; ### Symbolic Arithmetic

;; Symbols are interpreted as abstract complex numbers, and arithmetic on them
;; generates symbolic expressions.

(square (sin (+ 'a 3)))

;; Render to an infix string
;; with [`->infix`](https://cljdoc.org/d/sicmutils/sicmutils/CURRENT/api/sicmutils.expression.render#-%3Einfix):

(->infix
 (square (sin (+ 'a 3))))

;; Or to $\TeX$
;; with [`->TeX`](https://cljdoc.org/d/sicmutils/sicmutils/CURRENT/api/sicmutils.expression.render#-%3ETeX):

(clerk/tex
 (->TeX
  (square (sin (+ 'a 3)))))

;; > Note the additional `nextjournal.clerk/tex` wrapper here, signaling to the
;; > notebook that we should render the string returned by `->TeX` as $\TeX$.
;;
;; Let's define a `render` function that does this for us:

(def render (comp clerk/tex ->TeX))

;; `simplify` can simplify symbolic expressions:

(let [expr (+ (square (sin 'x))
              (square (cos 'x)))]
  (render
   [expr (simplify expr)]))

;; If you name a symbol after a greek letter, it will render to that letter.
;; Capitalize the first letter to get the capital version of the character:

(render
 (+ 'Theta 'alpha))

;; Special suffixes like `dot`, `dotdot`, `prime`, `primeprime`, `var`, `vec`
;; and `tilde` will modify the symbol's infix or $\LaTeX$ representation. `_`
;; triggers a subscript, and the unicode character â†‘ will trigger a superscript.

;; Here's a selection of examples:

(render
 (up
  'alphadot_beta
  'xdotdot
  'zetaprime_alphadot
  'alphaprimeprime_mubar
  'vbar
  'Pivec
  'alphatilde))

;; ### Automatic Differentiation

;; Use
;; the [`D`](https://cljdoc.org/d/sicmutils/sicmutils/CURRENT/api/sicmutils.calculus.derivative#D)
;; operator to perform [forward-mode automatic
;; differentiation](https://cljdoc.org/d/sicmutils/sicmutils/CURRENT/doc/calculus/automatic-differentiation).

(render
 ((D cube) 'x))

;; Generate the Taylor series expansion of a literal function `f` by
;; exponentiating the `D` operator:

(let [f (literal-function 'f)]
  (render
   (simplify
    (series:sum (((exp D) f) 'x) 5))))

;; ### Physics, Classical Mechanics

;; SICMUtils is based on the engine behind Sussman and Wisdom's [The Structure
;; and Interpretation of Classical
;; Mechanics](http://mitpress.mit.edu/books/structure-and-interpretation-classical-mechanics),
;; and has a built-in API for exploring Lagrangian and Hamiltonian mechanics.

;; Define a [Lagrangian](https://en.wikipedia.org/wiki/Lagrangian_mechanics) for
;; a central potential `U` acting on a particle with mass `m`:

(defn L-central-polar [m U]
  (fn [[_ [r] [rdot thetadot]]]
    (- (* 1/2 m
          (+ (square rdot)
             (square (* r thetadot))))
       (U r))))

;; and generate the two [Euler-Lagrange equations of
;; motion](https://en.wikipedia.org/wiki/Lagrangian_mechanics#Euler%E2%80%93Lagrange_equations_and_Hamilton's_principle)
;; for the `r` and `theta` coordinates:

(let [potential-fn (literal-function 'U)
      L     (L-central-polar 'm potential-fn)
      state (up (literal-function 'r)
                (literal-function 'theta))]
  (render
   (simplify
    (((Lagrange-equations L) state) 't))))
